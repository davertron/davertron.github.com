// Generated by CoffeeScript 1.3.3
(function() {
  var BabyCrossBoxEnemy, Box, Bullet, COLOR, CrossBoxEnemy, DiamondEnemy, Grid, HexGrid, MAIN_MENU_COLORS, Particle, PinWheelEnemy, SCREEN_HEIGHT, SCREEN_WIDTH, SPAWN_POINTS, Shield, Spaceship, Trail, WORLD_BOUNDS, animate, background, boxes, buildGameScene, buildMainMenuScene, camera, container, enemies, explosion, finalcomposer, finalshader, getSpawnPoint, glowcamera, glowcomposer, glowscene, godMode, grid, handleVisibilityChange, hblur, hexGrid, inMenu, init, initFinalComposer, lastTick, mainMenu, multiplier, onWindowResize, particles, paused, pointLight, render, renderTarget, renderTargetGlow, renderTargetParameters, renderer, replaceDead, rotateVector, scene, score, setGameOver, spaceship, stats, target, textures, update, updateScore, vblur, windowHalfX, windowHalfY;

  SCREEN_WIDTH = window.innerWidth;

  SCREEN_HEIGHT = window.innerHeight;

  COLOR = 0x97a8ba;

  container = null;

  stats = null;

  camera = null;

  glowcamera = null;

  target = null;

  scene = null;

  glowscene = null;

  renderer = null;

  renderTarget = null;

  renderTargetGlow = null;

  renderTargetParameters = {
    minFilter: THREE.LinearFilter,
    magFilter: THREE.LinearFilter,
    format: THREE.RGBFormat,
    stencilBuffer: false
  };

  boxes = [];

  spaceship = null;

  score = 0;

  multiplier = 1;

  godMode = false;

  enemies = [];

  particles = [];

  grid = null;

  hexGrid = null;

  background = null;

  lastTick = (new Date()).getTime();

  pointLight = null;

  finalcomposer = null;

  finalshader = null;

  glowcomposer = null;

  hblur = null;

  vblur = null;

  paused = false;

  inMenu = true;

  mainMenu = true;

  windowHalfX = window.innerWidth / 2;

  windowHalfY = window.innerHeight / 2;

  WORLD_BOUNDS = {
    minX: -500,
    maxX: 500,
    minY: -500,
    maxY: 500
  };

  SPAWN_POINTS = [new THREE.Vector3(-300, -300, 0), new THREE.Vector3(-300, 300, 0), new THREE.Vector3(300, -300, 0), new THREE.Vector3(300, 300, 0)];

  finalshader = {
    uniforms: {
      tDiffuse: {
        type: "t",
        value: 0,
        texture: null
      },
      tGlow: {
        type: "t",
        value: 1,
        texture: null
      },
      tGreyscale: {
        type: "t",
        value: 0,
        texture: null
      }
    },
    vertexShader: "varying vec2 vUv;        void main() {            vUv = vec2( uv.x, 1.0 - uv.y );            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );        }",
    fragmentShader: "uniform sampler2D tDiffuse;        uniform sampler2D tGlow;        uniform bool tGreyscale;        varying vec2 vUv;        void main() {            vec4 texel = texture2D( tDiffuse, vUv );            vec4 glow = texture2D( tGlow, vUv );            if(tGreyscale){                gl_FragColor = texel + vec4(0.5, 0.75, 1.0, 1.0) * glow * 4.0;                float gray = dot(gl_FragColor.rgb, vec3(0.299, 0.587, 0.114));                gl_FragColor = vec4(gray, gray, gray, gl_FragColor.a);            } else {                gl_FragColor = texel + vec4(0.5, 0.75, 1.0, 1.0) * glow * 4.0;            }        }"
  };

  MAIN_MENU_COLORS = [0xF84444, 0x66B002, 0xD586F5, 0x67E5E8, 0xF7FF00];

  textures = {
    galaxy: {
      url: '/img/galaxy.jpg',
      material: null
    }
  };

  rotateVector = function(vector, axis, rotation) {
    var matrix;
    matrix = new THREE.Matrix4().makeRotationAxis(axis, rotation);
    return matrix.multiplyVector3(vector);
  };

  Box = (function() {

    function Box(position, size, color, opacity) {
      var geometry, negSize;
      this.position = position != null ? position : new THREE.Vector3(0, 0, 0);
      this.size = size != null ? size : 5;
      this.color = color != null ? color : 0xffffff;
      this.opacity = opacity != null ? opacity : 1.0;
      geometry = new THREE.Geometry();
      negSize = -1 * this.size;
      geometry.vertices.push(new THREE.Vector3(negSize, negSize, 0), new THREE.Vector3(size, negSize, 0), new THREE.Vector3(size, size, 0), new THREE.Vector3(negSize, size, 0), new THREE.Vector3(negSize, negSize, 0));
      this.mesh = new THREE.Line(geometry, new THREE.LineBasicMaterial({
        color: this.color,
        opacity: this.opacity,
        linewidth: 3
      }));
      this.glowMesh = new THREE.Line(geometry, new THREE.LineBasicMaterial({
        color: this.color,
        opacity: this.opacity,
        linewidth: 3
      }));
      this.mesh.position = position;
      this.glowMesh.position = position;
    }

    Box.prototype.getMesh = function() {
      return this.mesh;
    };

    Box.prototype.getGlowMesh = function() {
      return this.glowMesh;
    };

    return Box;

  })();

  Trail = (function() {

    function Trail() {
      this.meshes = [];
      this.glowMeshes = [];
    }

    Trail.prototype.grow = function(position, scene, glowscene) {
      var glowMesh, newMesh, plane;
      plane = new THREE.PlaneGeometry(3, 3);
      newMesh = new THREE.Mesh(plane, new THREE.MeshBasicMaterial({
        color: 0xCC33FF,
        opacity: 0.5
      }));
      glowMesh = new THREE.Mesh(plane, new THREE.MeshBasicMaterial({
        color: 0xCC33FF,
        opacity: 0.5
      }));
      newMesh.position = position.clone();
      newMesh.age = 0;
      this.meshes.push(newMesh);
      scene.add(newMesh);
      glowMesh.position = position.clone();
      this.glowMeshes.push(glowMesh);
      return glowscene.add(glowMesh);
    };

    Trail.prototype.update = function(scene, glowscene) {
      var i, keepGlowMeshes, keepMeshes, mesh, _i, _len, _ref;
      keepMeshes = [];
      keepGlowMeshes = [];
      _ref = this.meshes;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        mesh = _ref[i];
        mesh.age += 1;
        if (mesh.age < 50) {
          mesh.scale.x *= 0.98;
          mesh.scale.y *= 0.98;
          this.glowMeshes[i].scale.x *= 0.98;
          this.glowMeshes[i].scale.y *= 0.98;
          keepMeshes.push(mesh);
          keepGlowMeshes.push(this.glowMeshes[i]);
        } else {
          scene.remove(mesh);
          glowscene.remove(this.glowMeshes[i]);
        }
      }
      this.meshes = keepMeshes;
      return this.glowMeshes = keepGlowMeshes;
    };

    return Trail;

  })();

  Bullet = (function() {

    function Bullet(position, velocity) {
      var geometry, vertex;
      this.velocity = velocity;
      this.position = position.clone();
      this.dead = false;
      this.lastUpdate = (new Date()).getTime();
      this.collideRadius = 5;
      geometry = new THREE.Geometry();
      vertex = this.velocity.clone().normalize();
      geometry.vertices.push(vertex, vertex.clone().multiplyScalar(10));
      this.mesh = new THREE.Line(geometry, new THREE.LineBasicMaterial({
        color: 0xFA3C23,
        opacity: 1.0,
        linewidth: 5
      }));
      this.mesh.position = this.position;
      this.glowMesh = new THREE.Line(geometry, new THREE.LineBasicMaterial({
        color: 0xFA3C23,
        opacity: 1.0,
        linewidth: 5
      }));
      this.glowMesh.position = this.position;
    }

    Bullet.prototype.update = function() {
      var now, scaledVelocity;
      now = (new Date()).getTime();
      scaledVelocity = this.velocity.clone().multiplyScalar((now - this.lastUpdate) / 1000);
      this.lastUpdate = now;
      if (!paused && !this.dead) {
        this.mesh.position = this.position.addSelf(scaledVelocity);
        this.glowMesh.position = this.position.addSelf(scaledVelocity);
        if (this.position.x > WORLD_BOUNDS.maxX || this.position.x < WORLD_BOUNDS.minX || this.position.y > WORLD_BOUNDS.maxY || this.position.y < WORLD_BOUNDS.minY) {
          return this.die(scene, glowscene);
        }
      }
    };

    Bullet.prototype.die = function(scene, glowscene) {
      this.dead = true;
      scene.remove(this.mesh);
      return glowscene.remove(this.glowMesh);
    };

    Bullet.prototype.spawn = function(scene, glowscene) {
      scene.add(this.mesh);
      return glowscene.add(this.glowMesh);
    };

    Bullet.prototype.collide = function(other) {
      if (!this.dead && !other.dead && this.position.clone().subSelf(other.position).length() <= (other.collideRadius + this.collideRadius)) {
        this.die(scene, glowscene);
        return other.die(scene, glowscene);
      }
    };

    return Bullet;

  })();

  updateScore = function(entity) {
    score += multiplier * entity.value;
    if (score % 100000 === 0) {
      spaceship.lives += 1;
      $('#lives').html('Lives: ' + spaceship.lives);
    }
    return $('#score').html('Score: ' + score);
  };

  Shield = (function() {

    function Shield(position) {
      var angleIncrement, color, geometry, opacity, radius;
      geometry = new THREE.Geometry();
      this.position = position || new THREE.Vector3(0, 0, 0);
      color = 0xffffff;
      opacity = 1.0;
      angleIncrement = (2 * Math.PI) / 8;
      radius = 15;
      geometry.vertices.push(new THREE.Vector3(radius, 0, 0), new THREE.Vector3(radius * Math.cos(angleIncrement), radius * Math.sin(angleIncrement), 0), new THREE.Vector3(radius * Math.cos(2 * angleIncrement), radius * Math.sin(2 * angleIncrement), 0), new THREE.Vector3(radius * Math.cos(3 * angleIncrement), radius * Math.sin(3 * angleIncrement), 0), new THREE.Vector3(radius * Math.cos(4 * angleIncrement), radius * Math.sin(4 * angleIncrement), 0), new THREE.Vector3(radius * Math.cos(5 * angleIncrement), radius * Math.sin(5 * angleIncrement), 0), new THREE.Vector3(radius * Math.cos(6 * angleIncrement), radius * Math.sin(6 * angleIncrement), 0), new THREE.Vector3(radius * Math.cos(7 * angleIncrement), radius * Math.sin(7 * angleIncrement), 0), new THREE.Vector3(radius, 0, 0));
      this.mesh = new THREE.Line(geometry, new THREE.LineBasicMaterial({
        color: color,
        opacity: opacity,
        linewidth: 3
      }));
      this.glowMesh = new THREE.Line(geometry, new THREE.LineBasicMaterial({
        color: color,
        opacity: opacity,
        linewidth: 3
      }));
      this.mesh.position = position;
      this.glowMesh.position = position;
    }

    Shield.prototype.spawn = function(scene, glowscene) {
      scene.add(this.mesh);
      return glowscene.add(this.glowMesh);
    };

    Shield.prototype.die = function(scene, glowscene) {
      scene.remove(this.mesh);
      return glowscene.remove(this.glowMesh);
    };

    return Shield;

  })();

  Spaceship = (function() {

    function Spaceship(position) {
      var color, geometry, heading, opacity, trailGeometry;
      geometry = new THREE.Geometry();
      trailGeometry = new THREE.Geometry();
      color = color || 0xffffff;
      opacity = opacity || 1.0;
      heading = new THREE.Vector3(0, 1, 0);
      this.heading = heading;
      if (position) {
        this.position = position.clone();
      } else {
        this.position = new THREE.Vector3(0, 0, 0);
      }
      this.velocity = 0;
      this.rotation = 0;
      this.trail = new Trail();
      this.bullets = [];
      this.shooting = false;
      this.lastShotTime;
      this.lastUpdate = (new Date()).getTime();
      this.lives = 3;
      this.type = 'Spaceship';
      this.collideRadius = 3;
      this.invincible = true;
      this.spawnTime = (new Date()).getTime();
      this.shield = new Shield(this.position.clone());
      geometry.vertices.push(new THREE.Vector3(0, -3, 0), new THREE.Vector3(-3, 0, 0), new THREE.Vector3(-2, 2, 0), new THREE.Vector3(-3, 0, 0), new THREE.Vector3(0, -1, 0), new THREE.Vector3(3, 0, 0), new THREE.Vector3(0, -3, 0), new THREE.Vector3(3, 0, 0), new THREE.Vector3(2, 2, 0));
      this.mesh = new THREE.Line(geometry, new THREE.LineBasicMaterial({
        color: color,
        opacity: opacity,
        linewidth: 3
      }));
      this.glowMesh = new THREE.Line(geometry, new THREE.LineBasicMaterial({
        color: color,
        opacity: opacity,
        linewidth: 3
      }));
      this.mesh.position = this.position;
      this.glowMesh.position = this.position;
      this.mesh.scale.x *= 3;
      this.mesh.scale.y *= 3;
      this.glowMesh.scale.x *= 3;
      this.glowMesh.scale.y *= 3;
    }

    Spaceship.prototype.reset = function() {
      this.heading = new THREE.Vector3(0, 1, 0);
      this.position = new THREE.Vector3(0, 0, 0);
      this.mesh.position = this.position;
      this.glowMesh.position = this.position;
      this.mesh.rotation.z = 0;
      this.glowMesh.rotation.z = 0;
      this.velocity = 0;
      this.rotation = 0;
      this.bullets = [];
      this.shooting = false;
      this.lastShotTime = null;
      this.lastUpdate = (new Date()).getTime();
      this.lives = 3;
      this.invincible = true;
      this.spawnTime = (new Date()).getTime();
      this.shield = new Shield(this.position.clone());
      return this.shield.spawn(scene, glowscene);
    };

    Spaceship.prototype.spawn = function(scene, glowscene) {
      this.spawnTime = (new Date()).getTime();
      this.shield.spawn(scene, glowscene);
      scene.add(this.mesh);
      return glowscene.add(this.glowMesh);
    };

    Spaceship.prototype.die = function(scene, glowscene) {
      var bullet, enemy, _i, _j, _len, _len1, _ref;
      this.lives -= 1;
      if (this.lives >= 0) {
        $('#lives').html('Lives: ' + this.lives);
      }
      if (this.lives > 0) {
        this.position = new THREE.Vector3(0, 0, 0);
        this.mesh.position = this.position.clone();
        this.glowMesh.position = this.position.clone();
        this.invincible = true;
        this.spawnTime = (new Date()).getTime();
        this.shield = new Shield(this.position.clone());
        this.shield.spawn(scene, glowscene);
        for (_i = 0, _len = enemies.length; _i < _len; _i++) {
          enemy = enemies[_i];
          enemy.die(scene, glowscene, false, false);
        }
        _ref = this.bullets;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          bullet = _ref[_j];
          bullet.die(scene, glowscene);
        }
        explosion(this.position, this.color, 1.0, 20, particles);
        return multiplier = 1;
      } else {
        return setGameOver();
      }
    };

    Spaceship.prototype.update = function(scene, glowscene, bounds) {
      now;

      timeScalar;

      scaledRotation;

      scaledVelocity;

      bullet;

      var bullet, enemy, now, scaledRotation, scaledVelocity, timeScalar, _i, _j, _len, _len1, _ref;
      for (_i = 0, _len = enemies.length; _i < _len; _i++) {
        enemy = enemies[_i];
        this.collide(enemy);
      }
      now = (new Date()).getTime();
      timeScalar = (now - this.lastUpdate) / 1000;
      if (this.rotation !== 0 && !paused) {
        scaledRotation = this.rotation * timeScalar;
        rotateVector(this.heading, new THREE.Vector3(0, 0, 1), scaledRotation);
        this.mesh.rotation.z += scaledRotation;
        this.glowMesh.rotation.z += scaledRotation;
      }
      scaledVelocity = timeScalar * this.velocity;
      if (!paused) {
        this.trail.update(scene, glowscene);
        if (now - this.spawnTime > 3000 && this.shield) {
          this.shield.die(scene, glowscene);
          this.shield = null;
          this.invincible = false;
        }
      }
      if (this.velocity !== 0 && !paused) {
        this.position = this.position.addSelf(this.heading.clone().multiplyScalar(scaledVelocity));
        this.mesh.position = this.position;
        this.glowMesh.position = this.position;
        if (this.shield) {
          this.shield.mesh.position = this.position.clone();
          this.shield.glowMesh.position = this.position.clone();
        }
        this.trail.grow(this.position.clone().subSelf(this.heading.clone().normalize().multiplyScalar(5)), scene, glowscene);
        if (this.position.x > bounds.maxX) {
          this.position.x = bounds.maxX;
        } else if (this.position.x < bounds.minX) {
          this.position.x = bounds.minX;
        }
        if (this.position.y > bounds.maxY) {
          this.position.y = bounds.maxY;
        } else if (this.position.y < bounds.minY) {
          this.position.y = bounds.minY;
        }
      }
      if (this.shooting && (!this.lastShotTime || (now - this.lastShotTime > 100)) && !paused) {
        bullet = new Bullet(this.position.clone(), this.heading.clone().normalize().multiplyScalar(600));
        bullet.spawn(scene, glowscene);
        replaceDead(bullet, this.bullets);
        this.lastShotTime = now;
      }
      _ref = this.bullets;
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        bullet = _ref[_j];
        bullet.update();
      }
      return this.lastUpdate = now;
    };

    Spaceship.prototype.collide = function(other) {
      if (!this.dead && !other.dead && this.position.clone().subSelf(other.position).length() <= (other.collideRadius + this.collideRadius)) {
        if (!godMode && !this.invincible) {
          this.die(scene, glowscene);
        }
        return other.die(scene, glowscene, false);
      }
    };

    return Spaceship;

  })();

  replaceDead = function(entity, array) {
    var i, object, spliced, _i, _len;
    spliced = false;
    for (i = _i = 0, _len = array.length; _i < _len; i = ++_i) {
      object = array[i];
      if (object.dead) {
        array.splice(i, 1, entity);
        spliced = true;
        break;
      }
    }
    if (!spliced) {
      return array.push(entity);
    }
  };

  DiamondEnemy = (function() {

    function DiamondEnemy(position, color, opacity) {
      var geometry;
      geometry = new THREE.Geometry();
      opacity = opacity || 1.0;
      if (position) {
        this.position = position.clone();
      } else {
        this.position = new THREE.Vector3(0, 0, 0);
      }
      this.velocity = spaceship.position.clone().subSelf(this.position).normalize().multiplyScalar(50);
      this.lastUpdate = (new Date()).getTime();
      this.collideRadius = 10;
      this.type = 'DiamondEnemy';
      this.value = 50;
      this.color = color || 0x14CEFC;
      geometry.vertices.push(new THREE.Vector3(-8, 0, 0), new THREE.Vector3(0, 10, 0), new THREE.Vector3(8, 0, 0), new THREE.Vector3(0, -10, 0), new THREE.Vector3(-8, 0, 0));
      this.mesh = new THREE.Line(geometry, new THREE.LineBasicMaterial({
        color: this.color,
        opacity: opacity,
        linewidth: 3
      }));
      this.glowMesh = new THREE.Line(geometry, new THREE.LineBasicMaterial({
        color: this.color,
        opacity: opacity,
        linewidth: 3
      }));
      this.mesh.position = this.position;
      this.glowMesh.position = this.position;
    }

    DiamondEnemy.prototype.update = function(scene, glowscene, bounds) {
      var now, scaledVelocity, velocityLength;
      now = (new Date()).getTime();
      velocityLength = this.velocity.length();
      scaledVelocity = this.velocity.clone().multiplyScalar((now - this.lastUpdate) / 1000);
      if (!paused && !this.dead) {
        if (Math.random() < 0.1) {
          this.velocity = spaceship.position.clone().subSelf(this.position).normalize().multiplyScalar(50);
          scaledVelocity = this.velocity.clone().multiplyScalar((now - this.lastUpdate) / 1000);
        }
        this.mesh.position = this.position.addSelf(scaledVelocity);
        this.glowMesh.position = this.position.addSelf(scaledVelocity);
        if (this.position.x > WORLD_BOUNDS.maxX || this.position.x < WORLD_BOUNDS.minX) {
          this.velocity.x *= -1;
        }
        if (this.position.y > WORLD_BOUNDS.maxY || this.position.y < WORLD_BOUNDS.minY) {
          this.velocity.y *= -1;
        }
      }
      return this.lastUpdate = now;
    };

    DiamondEnemy.prototype.spawn = function(scene, glowscene) {
      scene.add(this.mesh);
      return glowscene.add(this.glowMesh);
    };

    DiamondEnemy.prototype.die = function(scene, glowscene, shouldUpdateScore) {
      if (shouldUpdateScore == null) {
        shouldUpdateScore = true;
      }
      this.dead = true;
      scene.remove(this.mesh);
      glowscene.remove(this.glowMesh);
      explosion(this.position, this.color, 1.0, 20, particles);
      if (shouldUpdateScore) {
        return updateScore(this);
      }
    };

    return DiamondEnemy;

  })();

  PinWheelEnemy = (function() {

    function PinWheelEnemy(position, color, opacity) {
      var geometry;
      geometry = new THREE.Geometry();
      opacity = opacity || 1.0;
      if (position) {
        this.position = position.clone();
      } else {
        this.position = new THREE.Vector3(0, 0, 0);
      }
      this.velocity = new THREE.Vector3(Math.random() * 50, Math.random() * 50, 0).normalize().multiplyScalar(25);
      this.lastUpdate = (new Date()).getTime();
      this.collideRadius = 10;
      this.rotation = 0.5;
      this.type = 'PinWheelEnemy';
      this.value = 25;
      this.color = color || 0xCB49FF;
      geometry.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 8, 0), new THREE.Vector3(-8, 8, 0), new THREE.Vector3(0, 0, 0), new THREE.Vector3(-8, 0, 0), new THREE.Vector3(-8, -8, 0), new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, -8, 0), new THREE.Vector3(8, -8, 0), new THREE.Vector3(0, 0, 0), new THREE.Vector3(8, 0, 0), new THREE.Vector3(8, 8, 0), new THREE.Vector3(0, 0, 0));
      this.mesh = new THREE.Line(geometry, new THREE.LineBasicMaterial({
        color: this.color,
        opacity: opacity,
        linewidth: 3
      }));
      this.glowMesh = new THREE.Line(geometry, new THREE.LineBasicMaterial({
        color: this.color,
        opacity: opacity,
        linewidth: 3
      }));
      this.mesh.position = this.position;
      this.glowMesh.position = this.position;
    }

    PinWheelEnemy.prototype.update = function(scene, glowscene, bounds) {
      var now, scaledRotation, scaledVelocity, timeScalar;
      now = (new Date()).getTime();
      timeScalar = (now - this.lastUpdate) / 1000;
      scaledVelocity = this.velocity.clone().multiplyScalar(timeScalar);
      scaledRotation = this.rotation * timeScalar;
      if (!paused && !this.dead) {
        if (Math.random() < 0.1) {
          rotateVector(this.velocity, new THREE.Vector3(0, 0, 1), Math.sin(now * Math.random()) * 0.25);
        }
        this.mesh.position = this.position.addSelf(scaledVelocity);
        this.glowMesh.position = this.position.addSelf(scaledVelocity);
        this.mesh.rotation.z += scaledRotation;
        this.glowMesh.rotation.z += scaledRotation;
        if (this.position.x > WORLD_BOUNDS.maxX || this.position.x < WORLD_BOUNDS.minX) {
          this.velocity.x *= -1;
        }
        if (this.position.y > WORLD_BOUNDS.maxY || this.position.y < WORLD_BOUNDS.minY) {
          this.velocity.y *= -1;
        }
      }
      return this.lastUpdate = now;
    };

    PinWheelEnemy.prototype.spawn = function(scene, glowscene) {
      scene.add(this.mesh);
      return glowscene.add(this.glowMesh);
    };

    PinWheelEnemy.prototype.die = function(scene, glowscene, shouldUpdateScore) {
      if (shouldUpdateScore == null) {
        shouldUpdateScore = true;
      }
      this.dead = true;
      scene.remove(this.mesh);
      glowscene.remove(this.glowMesh);
      explosion(this.position, this.color, 1.0, 20, particles);
      if (shouldUpdateScore) {
        return updateScore(this);
      }
    };

    return PinWheelEnemy;

  })();

  CrossBoxEnemy = (function() {

    function CrossBoxEnemy(position, color, opacity) {
      var geometry;
      geometry = new THREE.Geometry();
      opacity = opacity || 1.0;
      if (position) {
        this.position = position.clone();
      } else {
        this.position = new THREE.Vector3(0, 0, 0);
      }
      this.velocity = new THREE.Vector3(Math.random() * 50, Math.random() * 50, 0).normalize().multiplyScalar(50);
      this.lastUpdate = (new Date()).getTime();
      this.collideRadius = 10;
      this.rotation = 0.5;
      this.type = 'CrossBoxEnemy';
      this.value = 75;
      this.color = color || 0xFF4AD5;
      geometry.vertices.push(new THREE.Vector3(-8, 8, 0), new THREE.Vector3(8, 8, 0), new THREE.Vector3(-8, -8, 0), new THREE.Vector3(-8, 8, 0), new THREE.Vector3(8, -8, 0), new THREE.Vector3(-8, -8, 0), new THREE.Vector3(8, 8, 0), new THREE.Vector3(8, -8, 0));
      this.mesh = new THREE.Line(geometry, new THREE.LineBasicMaterial({
        color: this.color,
        opacity: opacity,
        linewidth: 3
      }));
      this.glowMesh = new THREE.Line(geometry, new THREE.LineBasicMaterial({
        color: this.color,
        opacity: opacity,
        linewidth: 3
      }));
      this.mesh.position = this.position;
      this.glowMesh.position = this.position;
    }

    CrossBoxEnemy.prototype.update = function(scene, glowscene, bounds) {
      var now, scaledVelocity, timeScalar;
      now = (new Date()).getTime();
      timeScalar = (now - this.lastUpdate) / 1000;
      scaledVelocity = this.velocity.clone().multiplyScalar(timeScalar);
      if (!paused && !this.dead) {
        if (Math.random() < 0.1) {
          this.velocity = spaceship.position.clone().subSelf(this.position).normalize().multiplyScalar(50);
          scaledVelocity = this.velocity.clone().multiplyScalar((now - this.lastUpdate) / 1000);
        }
        this.mesh.position = this.position.addSelf(scaledVelocity);
        this.glowMesh.position = this.position.addSelf(scaledVelocity);
        if (this.position.x > WORLD_BOUNDS.maxX || this.position.x < WORLD_BOUNDS.minX) {
          this.velocity.x *= -1;
        }
        if (this.position.y > WORLD_BOUNDS.maxY || this.position.y < WORLD_BOUNDS.minY) {
          this.velocity.y *= -1;
        }
      }
      return this.lastUpdate = now;
    };

    CrossBoxEnemy.prototype.spawn = function(scene, glowscene) {
      scene.add(this.mesh);
      return glowscene.add(this.glowMesh);
    };

    CrossBoxEnemy.prototype.die = function(scene, glowscene, shouldUpdateScore, shouldSpawnBabies) {
      var baby, i, _i, _results;
      if (shouldUpdateScore == null) {
        shouldUpdateScore = true;
      }
      if (shouldSpawnBabies == null) {
        shouldSpawnBabies = true;
      }
      this.dead = true;
      scene.remove(this.mesh);
      glowscene.remove(this.glowMesh);
      explosion(this.position, this.color, 1.0, 20, particles);
      if (shouldUpdateScore) {
        updateScore(this);
      }
      if (shouldSpawnBabies) {
        _results = [];
        for (i = _i = 0; _i <= 2; i = ++_i) {
          baby = new BabyCrossBoxEnemy(this.position.clone().addSelf(new THREE.Vector3(Math.random() * 20, Math.random() * 20, 0)), this.color, this.opacity);
          replaceDead(baby, enemies);
          _results.push(baby.spawn(scene, glowscene));
        }
        return _results;
      }
    };

    return CrossBoxEnemy;

  })();

  BabyCrossBoxEnemy = (function() {

    function BabyCrossBoxEnemy(position, color, opacity) {
      var geometry;
      geometry = new THREE.Geometry();
      opacity = opacity || 1.0;
      if (position) {
        this.position = position.clone();
      } else {
        this.position = new THREE.Vector3(0, 0, 0);
      }
      this.velocity = new THREE.Vector3(Math.random(), Math.random(), 0).normalize().multiplyScalar(50);
      this.lastUpdate = (new Date()).getTime();
      this.collideRadius = 10;
      this.type = 'BabyCrossBoxEnemy';
      this.value = 25;
      this.color = color || 0xFF4AD5;
      geometry.vertices.push(new THREE.Vector3(-8, 8, 0), new THREE.Vector3(8, 8, 0), new THREE.Vector3(-8, -8, 0), new THREE.Vector3(-8, 8, 0), new THREE.Vector3(8, -8, 0), new THREE.Vector3(-8, -8, 0), new THREE.Vector3(8, 8, 0), new THREE.Vector3(8, -8, 0));
      this.mesh = new THREE.Line(geometry, new THREE.LineBasicMaterial({
        color: this.color,
        opacity: opacity,
        linewidth: 3
      }));
      this.glowMesh = new THREE.Line(geometry, new THREE.LineBasicMaterial({
        color: this.color,
        opacity: opacity,
        linewidth: 3
      }));
      this.mesh.position = this.position;
      this.glowMesh.position = this.position;
      this.mesh.scale.x *= 0.5;
      this.mesh.scale.y *= 0.5;
      this.glowMesh.scale.x *= 0.5;
      this.glowMesh.scale.y *= 0.5;
    }

    BabyCrossBoxEnemy.prototype.update = function() {
      var now, scaledVelocity, timeScalar, vectorTowardsSpaceship;
      now = (new Date()).getTime();
      timeScalar = (now - this.lastUpdate) / 1000;
      scaledVelocity = this.velocity.clone().multiplyScalar(timeScalar);
      vectorTowardsSpaceship;

      if (!paused && !this.dead) {
        rotateVector(this.velocity, new THREE.Vector3(0, 0, 1), 0.1);
        vectorTowardsSpaceship = spaceship.position.clone().subSelf(this.position);
        if (Math.acos(this.velocity.normalize().dot(vectorTowardsSpaceship.normalize())) < 1.5) {
          this.velocity.normalize().multiplyScalar(100);
        } else {
          this.velocity.normalize().multiplyScalar(50);
        }
        this.mesh.position = this.position.addSelf(scaledVelocity);
        this.glowMesh.position = this.position.addSelf(scaledVelocity);
        if (this.position.x > WORLD_BOUNDS.maxX || this.position.x < WORLD_BOUNDS.minX) {
          this.velocity.x *= -1;
        }
        if (this.position.y > WORLD_BOUNDS.maxY || this.position.y < WORLD_BOUNDS.minY) {
          this.velocity.y *= -1;
        }
      }
      return this.lastUpdate = now;
    };

    BabyCrossBoxEnemy.prototype.spawn = function(scene, glowscene) {
      scene.add(this.mesh);
      return glowscene.add(this.glowMesh);
    };

    BabyCrossBoxEnemy.prototype.die = function(scene, glowscene, shouldUpdateScore) {
      if (shouldUpdateScore == null) {
        shouldUpdateScore = true;
      }
      this.dead = true;
      scene.remove(this.mesh);
      glowscene.remove(this.glowMesh);
      explosion(this.position, this.color, 1.0, 20, particles);
      if (shouldUpdateScore) {
        return updateScore(this);
      }
    };

    return BabyCrossBoxEnemy;

  })();

  Grid = (function() {

    function Grid(x, y, width, height, span, color, opacity, linewidth) {
      var currentX, currentY, geometry, maxX, maxY, minX, minY, numberOfXLines, numberOfYLines, _i, _j;
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      this.span = span;
      this.color = color != null ? color : 0xffffff;
      this.opacity = opacity != null ? opacity : 1.0;
      this.linewidth = linewidth != null ? linewidth : 1;
      this.meshes = [];
      this.glowMeshes = [];
      numberOfXLines = width / span;
      numberOfYLines = height / span;
      minX = x;
      maxX = minX + width;
      minY = y;
      maxY = minY + height;
      geometry;

      for (currentX = _i = 0; 0 <= numberOfXLines ? _i <= numberOfXLines : _i >= numberOfXLines; currentX = 0 <= numberOfXLines ? ++_i : --_i) {
        geometry = new THREE.Geometry();
        geometry.vertices.push(new THREE.Vector3(minX + (currentX * span), minY, 0), new THREE.Vector3(minX + (currentX * span), maxY, 0));
        this.meshes.push(new THREE.Line(geometry, new THREE.LineBasicMaterial({
          color: this.color,
          opacity: this.opacity,
          linewidth: this.linewidth
        })));
        this.glowMeshes.push(new THREE.Line(geometry, new THREE.LineBasicMaterial({
          color: this.color,
          opacity: this.opacity,
          linewidth: this.linewidth
        })));
      }
      for (currentY = _j = 0; 0 <= numberOfYLines ? _j <= numberOfYLines : _j >= numberOfYLines; currentY = 0 <= numberOfYLines ? ++_j : --_j) {
        geometry = new THREE.Geometry();
        geometry.vertices.push(new THREE.Vector3(minX, minY + (currentY * span), 0), new THREE.Vector3(maxX, minY + (currentY * span), 0));
        this.meshes.push(new THREE.Line(geometry, new THREE.LineBasicMaterial({
          color: color,
          opacity: opacity,
          linewidth: 1
        })));
        this.glowMeshes.push(new THREE.Line(geometry, new THREE.LineBasicMaterial({
          color: color,
          opacity: opacity,
          linewidth: 1
        })));
      }
    }

    Grid.prototype.spawn = function(scene, glowscene) {
      var glowMesh, mesh, _i, _j, _len, _len1, _ref, _ref1, _results;
      _ref = this.meshes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        mesh = _ref[_i];
        scene.add(mesh);
      }
      _ref1 = this.glowMeshes;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        glowMesh = _ref1[_j];
        _results.push(glowscene.add(glowMesh));
      }
      return _results;
    };

    return Grid;

  })();

  HexGrid = (function() {

    function HexGrid(x, y, width, height, span, color, opacity) {
      var currentXHex, currentYHex, geometry, halfSpan, maxX, maxY, minX, minY, numberOfXHexagons, numberOfYHexagons, quarterSpan, threeQuarterSpan, xOffset, yOffset, _i, _j;
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      this.span = span;
      this.color = color != null ? color : 0xffffff;
      this.opacity = opacity != null ? opacity : 1.0;
      this.meshes = [];
      this.glowMeshes = [];
      numberOfXHexagons = width / span;
      numberOfYHexagons = height / span;
      minX = x;
      maxX = minX + width;
      minY = y;
      maxY = minY + height;
      geometry;

      halfSpan = this.span / 2;
      quarterSpan = halfSpan / 2;
      threeQuarterSpan = halfSpan + quarterSpan;
      X;

      Y;

      xOffset;

      yOffset;

      for (currentXHex = _i = 0; 0 <= numberOfXHexagons ? _i <= numberOfXHexagons : _i >= numberOfXHexagons; currentXHex = 0 <= numberOfXHexagons ? ++_i : --_i) {
        for (currentYHex = _j = 0; 0 <= numberOfYHexagons ? _j <= numberOfYHexagons : _j >= numberOfYHexagons; currentYHex = 0 <= numberOfYHexagons ? ++_j : --_j) {
          xOffset = (currentXHex * threeQuarterSpan) + minX;
          yOffset = (currentYHex * span) + minY;
          if (currentXHex % 2 === 0) {
            yOffset -= halfSpan;
          }
          geometry = new THREE.Geometry();
          geometry.vertices.push(new THREE.Vector3(xOffset + quarterSpan, yOffset, 0), new THREE.Vector3(xOffset + threeQuarterSpan, yOffset, 0), new THREE.Vector3(xOffset + span, yOffset + halfSpan, 0), new THREE.Vector3(xOffset + threeQuarterSpan, yOffset + span, 0), new THREE.Vector3(xOffset + quarterSpan, yOffset + span, 0), new THREE.Vector3(xOffset, yOffset + halfSpan, 0), new THREE.Vector3(xOffset + quarterSpan, yOffset, 0));
          this.meshes.push(new THREE.Line(geometry, new THREE.LineBasicMaterial({
            color: this.color,
            opacity: this.opacity,
            linewidth: 3
          })));
          geometry = new THREE.Geometry();
          geometry.vertices.push(new THREE.Vector3(xOffset + quarterSpan, yOffset, 0), new THREE.Vector3(xOffset + threeQuarterSpan, yOffset, 0), new THREE.Vector3(xOffset + span, yOffset + halfSpan, 0), new THREE.Vector3(xOffset + threeQuarterSpan, yOffset + span, 0), new THREE.Vector3(xOffset + quarterSpan, yOffset + span, 0), new THREE.Vector3(xOffset, yOffset + halfSpan, 0), new THREE.Vector3(xOffset + quarterSpan, yOffset, 0));
          this.glowMeshes.push(new THREE.Line(geometry, new THREE.LineBasicMaterial({
            color: this.color,
            opacity: this.opacity,
            linewidth: 3
          })));
        }
      }
    }

    HexGrid.prototype.spawn = function(scene, glowscene) {
      var glowMesh, mesh, _i, _j, _len, _len1, _ref, _ref1, _results;
      _ref = this.meshes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        mesh = _ref[_i];
        scene.add(mesh);
      }
      _ref1 = this.glowMeshes;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        glowMesh = _ref1[_j];
        _results.push(glowscene.add(glowMesh));
      }
      return _results;
    };

    return HexGrid;

  })();

  Particle = (function() {

    function Particle(position, velocity, maxAge, color, opacity) {
      var geometry;
      this.maxAge = maxAge != null ? maxAge : 25;
      this.color = color != null ? color : 0xFDA014;
      this.opacity = opacity != null ? opacity : 1.0;
      geometry = new THREE.Geometry();
      this.position = position || new THREE.Vector3(0, 0, 0);
      this.velocity = velocity || new THREE.Vector3(0, 1, 0);
      this.age = 0;
      this.lastUpdate = (new Date()).getTime();
      this.dead = false;
      geometry.vertices.push(new THREE.Vector3(0, 0, 0), velocity.clone().normalize().multiplyScalar(10));
      this.mesh = new THREE.Line(geometry, new THREE.LineBasicMaterial({
        color: this.color,
        opacity: this.opacity,
        linewidth: 2
      }));
      this.glowMesh = new THREE.Line(geometry, new THREE.LineBasicMaterial({
        color: this.color,
        opacity: this.opacity,
        linewidth: 2
      }));
      this.mesh.position = this.position;
      this.glowMesh.position = this.position;
    }

    Particle.prototype.spawn = function(scene, glowscene) {
      scene.add(this.mesh);
      return glowscene.add(this.glowMesh);
    };

    Particle.prototype.die = function(scene, glowscene) {
      this.dead = true;
      scene.remove(this.mesh);
      return glowscene.remove(this.glowMesh);
    };

    Particle.prototype.update = function() {
      var ageScalar, now, scaledVelocity, timeScalar;
      now = (new Date()).getTime();
      timeScalar;

      ageScalar;

      scaledVelocity;

      this.age += 1;
      if (this.age >= this.maxAge) {
        this.die(scene, glowscene);
      }
      if (!paused && !this.dead) {
        timeScalar = (now - this.lastUpdate) / 1000;
        ageScalar = (this.maxAge - this.age) / this.maxAge;
        scaledVelocity = this.velocity.clone().multiplyScalar(timeScalar * ageScalar);
        this.mesh.position = this.position.addSelf(scaledVelocity);
        this.glowMesh.position = this.position.addSelf(scaledVelocity);
        if (this.position.x > WORLD_BOUNDS.maxX || this.position.x < WORLD_BOUNDS.minX) {
          this.velocity.x *= -1;
        }
        if (this.position.y > WORLD_BOUNDS.maxY || this.position.y < WORLD_BOUNDS.minY) {
          this.velocity.y *= -1;
        }
      }
      return this.lastUpdate = now;
    };

    return Particle;

  })();

  explosion = function(position, color, opacity, numberOfParticles, particles) {
    var angleIncrement, i, p, x, y, _i, _results;
    if (opacity == null) {
      opacity = 1.0;
    }
    angleIncrement = (2 * Math.PI) / numberOfParticles;
    x;

    y;

    p;

    _results = [];
    for (i = _i = 0; 0 <= numberOfParticles ? _i <= numberOfParticles : _i >= numberOfParticles; i = 0 <= numberOfParticles ? ++_i : --_i) {
      x = Math.cos(i * angleIncrement);
      y = Math.sin(i * angleIncrement);
      p = new Particle(position.clone(), (new THREE.Vector3(x, y, 0)).normalize().multiplyScalar(250), 50, color, opacity);
      replaceDead(p, particles);
      _results.push(p.spawn(scene, glowscene));
    }
    return _results;
  };

  window.unpause = function() {
    paused = false;
    inMenu = false;
    finalshader.uniforms['tGreyscale'].value = false;
    initFinalComposer(finalshader, scene, camera, renderer, renderTarget);
    return $('.menu').removeClass('current').hide();
  };

  window.pause = function() {
    $('.menu').removeClass('current').hide();
    paused = true;
    inMenu = true;
    finalshader.uniforms['tGreyscale'].value = true;
    initFinalComposer(finalshader, scene, camera, renderer, renderTarget);
    return $('#paused').addClass('current').find('.menu-actions li').removeClass('selected').first().addClass('selected').end().end().show();
  };

  setGameOver = function() {
    inMenu = true;
    paused = true;
    finalshader.uniforms['tGreyscale'].value = true;
    initFinalComposer(finalshader, scene, camera, renderer, renderTarget);
    $('.menu').removeClass('current').hide();
    return $('#game-over').addClass('current').find('.menu-actions li').removeClass('selected').first().addClass('selected').end().end().show();
  };

  window.start = function() {
    mainMenu = false;
    inMenu = false;
    unpause();
    $('.menu').removeClass('current').hide();
    buildGameScene();
    return $('#hud').show();
  };

  window.goToMainMenu = function() {
    unpause();
    mainMenu = true;
    inMenu = true;
    $('.menu').removeClass('current').hide();
    buildMainMenuScene();
    $('#hud').hide();
    return $('#main-menu').addClass('current').find('.menu-actions li').removeClass('selected').first().addClass('selected').end().end().show();
  };

  window.showControls = function() {
    $('.menu').removeClass('current').hide();
    return $('#controls').addClass('current').find('.menu-actions li').removeClass('selected').first().addClass('selected').end().end().show();
  };

  window.restart = function() {
    var bullet, enemy, particle, _i, _j, _k, _len, _len1, _len2, _ref;
    for (_i = 0, _len = enemies.length; _i < _len; _i++) {
      enemy = enemies[_i];
      enemy.die(scene, glowscene, false);
    }
    _ref = spaceship.bullets;
    for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
      bullet = _ref[_j];
      bullet.die(scene, glowscene);
    }
    for (_k = 0, _len2 = particles.length; _k < _len2; _k++) {
      particle = particles[_k];
      particle.die(scene, glowscene);
    }
    spaceship.reset();
    enemies = [];
    particles = [];
    score = 0;
    multiplier = 0;
    $('#score').html('Score: ' + score);
    $('#lives').html('Lives: ' + spaceship.lives);
    paused = false;
    finalshader.uniforms['tGreyscale'].value = false;
    initFinalComposer(finalshader, scene, camera, renderer, renderTarget);
    $('.menu').hide();
    return $('#game-over li').removeClass('selected').first().addClass('selected');
  };

  buildMainMenuScene = function() {
    var bluriness, cameraLight, renderModelGlow;
    camera = new THREE.PerspectiveCamera(75, SCREEN_WIDTH / SCREEN_HEIGHT, 1, 100000);
    camera.position.z = 50;
    camera.position.y = 0;
    cameraLight = new THREE.PointLight(0x666666);
    camera.add(cameraLight);
    scene = new THREE.Scene();
    scene.add(new THREE.AmbientLight(0xffffff));
    pointLight = new THREE.PointLight(COLOR);
    pointLight.position.set(0, 100, 0);
    scene.add(pointLight);
    glowscene = new THREE.Scene();
    glowscene.add(new THREE.AmbientLight(0xffffff));
    glowcamera = new THREE.PerspectiveCamera(75, SCREEN_WIDTH / SCREEN_HEIGHT, 1, 100000);
    glowcamera.position = camera.position;
    spaceship = new Spaceship();
    spaceship.spawn(scene, glowscene);
    renderTargetGlow = new THREE.WebGLRenderTarget(SCREEN_WIDTH, SCREEN_HEIGHT, renderTargetParameters);
    hblur = new THREE.ShaderPass(THREE.ShaderExtras["horizontalBlur"]);
    vblur = new THREE.ShaderPass(THREE.ShaderExtras["verticalBlur"]);
    bluriness = 2;
    hblur.uniforms['h'].value = bluriness / SCREEN_WIDTH;
    vblur.uniforms['v'].value = bluriness / SCREEN_HEIGHT;
    renderModelGlow = new THREE.RenderPass(glowscene, glowcamera);
    glowcomposer = new THREE.EffectComposer(renderer, renderTargetGlow);
    glowcomposer.addPass(renderModelGlow);
    glowcomposer.addPass(hblur);
    glowcomposer.addPass(vblur);
    finalshader.uniforms['tGlow'].texture = glowcomposer.renderTarget2;
    renderTarget = new THREE.WebGLRenderTarget(SCREEN_WIDTH, SCREEN_HEIGHT, renderTargetParameters);
    return initFinalComposer(finalshader, scene, camera, renderer, renderTarget, renderTargetParameters);
  };

  buildGameScene = function() {
    var bluriness, cameraLight, renderModelGlow;
    camera = new THREE.PerspectiveCamera(75, SCREEN_WIDTH / SCREEN_HEIGHT, 1, 100000);
    camera.position.z = 280;
    cameraLight = new THREE.PointLight(0x666666);
    camera.add(cameraLight);
    scene = new THREE.Scene();
    scene.add(new THREE.AmbientLight(0xffffff));
    pointLight = new THREE.PointLight(COLOR);
    pointLight.position.set(0, 100, 0);
    scene.add(pointLight);
    glowscene = new THREE.Scene();
    glowscene.add(new THREE.AmbientLight(0xffffff));
    glowcamera = new THREE.PerspectiveCamera(75, SCREEN_WIDTH / SCREEN_HEIGHT, 1, 100000);
    glowcamera.position = camera.position;
    particles = [];
    spaceship = new Spaceship();
    spaceship.spawn(scene, glowscene);
    grid = new Grid(WORLD_BOUNDS.minX, WORLD_BOUNDS.minY, 1000, 1000, 20, 0xb8f35b, 0.1, 2);
    grid.spawn(scene, glowscene);
    renderTargetGlow = new THREE.WebGLRenderTarget(SCREEN_WIDTH, SCREEN_HEIGHT, renderTargetParameters);
    hblur = new THREE.ShaderPass(THREE.ShaderExtras["horizontalBlur"]);
    vblur = new THREE.ShaderPass(THREE.ShaderExtras["verticalBlur"]);
    bluriness = 2;
    hblur.uniforms['h'].value = bluriness / SCREEN_WIDTH;
    vblur.uniforms['v'].value = bluriness / SCREEN_HEIGHT;
    renderModelGlow = new THREE.RenderPass(glowscene, glowcamera);
    glowcomposer = new THREE.EffectComposer(renderer, renderTargetGlow);
    glowcomposer.addPass(renderModelGlow);
    glowcomposer.addPass(hblur);
    glowcomposer.addPass(vblur);
    finalshader.uniforms['tGlow'].texture = glowcomposer.renderTarget2;
    renderTarget = new THREE.WebGLRenderTarget(SCREEN_WIDTH, SCREEN_HEIGHT, renderTargetParameters);
    return initFinalComposer(finalshader, scene, camera, renderer, renderTarget, renderTargetParameters);
  };

  init = function() {
    var $container, bluriness, nextItem, previousItem, renderModelGlow, selectedItem;
    bluriness = null;
    renderModelGlow = null;
    $container = null;
    nextItem = null;
    previousItem = null;
    selectedItem = null;
    container = document.createElement('div');
    container.id = 'container';
    document.body.appendChild(container);
    $(document).keydown(function(e) {
      if (inMenu) {
        $container = $('.menu.current .menu-actions');
        if (e.keyCode === 40 || e.keyCode === 83) {
          nextItem = $container.find('.selected').next();
          $container.find('li').removeClass('selected');
          if (nextItem.length > 0) {
            return $(nextItem).addClass('selected');
          } else {
            return $container.find('li:first').addClass('selected');
          }
        } else if (e.keyCode === 38 || e.keyCode === 87) {
          previousItem = $container.find('.selected').prev();
          $container.find('li').removeClass('selected');
          if (previousItem.length > 0) {
            return $(previousItem).addClass('selected');
          } else {
            return $container.find('li:last').addClass('selected');
          }
        } else if (e.keyCode === 13) {
          selectedItem = $container.find('.selected');
          return window[selectedItem.data('action')]();
        }
      } else {
        if (e.keyCode === 68) {
          return spaceship.rotation = 2.5;
        } else if (e.keyCode === 65) {
          return spaceship.rotation = -2.5;
        } else if (e.keyCode === 87) {
          return spaceship.velocity = 175;
        } else if (e.keyCode === 32) {
          return spaceship.shooting = true;
        } else if (e.keyCode === 80) {
          if (paused) {
            return unpause();
          } else {
            return pause();
          }
        }
      }
    });
    $(document).keyup(function(e) {
      if (inMenu) {

      } else {
        if (e.keyCode === 68 || e.keyCode === 65) {
          return spaceship.rotation = 0;
        } else if (e.keyCode === 87) {
          return spaceship.velocity = 0;
        } else if (e.keyCode === 32) {
          return spaceship.shooting = false;
        }
      }
    });
    renderer = new THREE.WebGLRenderer({});
    renderer.autoClear = false;
    renderer.sortObjects = true;
    renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
    renderer.domElement.style.position = "relative";
    container.appendChild(renderer.domElement);
    stats = new Stats();
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.top = '0px';
    stats.domElement.style.zIndex = 100;
    container.appendChild(stats.domElement);
    window.addEventListener('resize', onWindowResize, false);
    return document.addEventListener("webkitvisibilitychange", handleVisibilityChange, false);
  };

  initFinalComposer = function(finalShader, scene, camera, renderer, renderTarget, renderTargetParameters) {
    var finalPass, renderModel;
    renderModel = new THREE.RenderPass(scene, camera);
    finalPass = new THREE.ShaderPass(finalshader);
    finalPass.needsSwap = true;
    finalPass.renderToScreen = true;
    finalcomposer = new THREE.EffectComposer(renderer, renderTarget);
    if (!paused) {
      finalcomposer.addPass(renderModel);
    }
    return finalcomposer.addPass(finalPass);
  };

  onWindowResize = function() {
    windowHalfX = window.innerWidth / 2;
    windowHalfY = window.innerHeight / 2;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    glowcamera.aspect = window.innerWidth / window.innerHeight;
    glowcamera.updateProjectionMatrix();
    return renderer.setSize(window.innerWidth, window.innerHeight);
  };

  handleVisibilityChange = function() {
    if (document.webkitHidden && !inMenu) {
      return pause();
    }
  };

  animate = function() {
    update();
    render();
    stats.update();
    return requestAnimationFrame(animate);
  };

  getSpawnPoint = function(SPAWN_POINTS) {
    var distanceFromSpaceship, numberOfSpawnPoints, spawnPoint;
    numberOfSpawnPoints = SPAWN_POINTS.length;
    spawnPoint = SPAWN_POINTS[parseInt(Math.random() * numberOfSpawnPoints, 10)];
    distanceFromSpaceship = spawnPoint.clone().subSelf(spaceship.position).length();
    while (distanceFromSpaceship < 50) {
      spawnPoint = SPAWN_POINTS[parseInt(Math.random() * numberOfSpawnPoints, 10)];
      distanceFromSpaceship = spawnPoint.clone().subSelf(spaceship.position).length();
    }
    return spawnPoint;
  };

  update = function() {
    var baby1, baby2, baby3, babyCrossBoxesToAdd, bullet, c, e, enemy, mainMenuRotation, newX, newY, now, p, particle, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _results, _results1;
    now = null;
    newX = null;
    newY = null;
    e = null;
    p = null;
    c = null;
    babyCrossBoxesToAdd = [];
    baby1 = null;
    baby2 = null;
    baby3 = null;
    mainMenuRotation = 0.01;
    if (mainMenu) {
      spaceship.mesh.rotation.x += mainMenuRotation;
      spaceship.mesh.rotation.y += mainMenuRotation;
      spaceship.mesh.rotation.z += mainMenuRotation;
      spaceship.glowMesh.rotation.x += mainMenuRotation;
      spaceship.glowMesh.rotation.y += mainMenuRotation;
      spaceship.glowMesh.rotation.z += mainMenuRotation;
      for (_i = 0, _len = particles.length; _i < _len; _i++) {
        particle = particles[_i];
        if (!particle.dead) {
          particle.update();
        }
      }
      if (Math.random() < 0.2) {
        return explosion(new THREE.Vector3((Math.random() * 200) - 100, (Math.random() * 200) - 100, -200), MAIN_MENU_COLORS[Math.floor(Math.random() * MAIN_MENU_COLORS.length)], 0.5, 20, particles);
      }
    } else {
      spaceship.update(scene, glowscene, WORLD_BOUNDS);
      if (paused) {
        now = (new Date()).getTime();
        newX = 100 * Math.sin(now / 2000);
        newY = 100 * Math.sin(now / -3500);
        camera.position.x = spaceship.position.x + newX;
        camera.position.y = spaceship.position.y + newY;
        _results = [];
        for (_j = 0, _len1 = enemies.length; _j < _len1; _j++) {
          enemy = enemies[_j];
          _results.push(enemy.update(scene, glowscene, WORLD_BOUNDS));
        }
        return _results;
      } else {
        camera.position.x = spaceship.position.x;
        camera.position.y = spaceship.position.y;
        if (Math.random() < 0.01) {
          e = new DiamondEnemy(getSpawnPoint(SPAWN_POINTS), null, 0.8);
          replaceDead(e, enemies);
          e.spawn(scene, glowscene);
        }
        if (Math.random() < 0.01) {
          p = new PinWheelEnemy(getSpawnPoint(SPAWN_POINTS), null, 0.8);
          replaceDead(p, enemies);
          p.spawn(scene, glowscene);
        }
        if (Math.random() < 0.005) {
          c = new CrossBoxEnemy(getSpawnPoint(SPAWN_POINTS), null, 0.8);
          replaceDead(c, enemies);
          c.spawn(scene, glowscene);
        }
        for (_k = 0, _len2 = enemies.length; _k < _len2; _k++) {
          enemy = enemies[_k];
          if (!enemy.dead) {
            enemy.update(scene, glowscene, WORLD_BOUNDS);
            _ref = spaceship.bullets;
            for (_l = 0, _len3 = _ref.length; _l < _len3; _l++) {
              bullet = _ref[_l];
              if (!bullet.dead) {
                bullet.collide(enemy);
              }
            }
          }
        }
        _results1 = [];
        for (_m = 0, _len4 = particles.length; _m < _len4; _m++) {
          particle = particles[_m];
          _results1.push(particle.update());
        }
        return _results1;
      }
    }
  };

  render = function() {
    glowcomposer.render(0.1);
    return finalcomposer.render(0.1);
  };

  init();

  buildMainMenuScene();

  animate();

}).call(this);
